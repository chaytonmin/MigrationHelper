package edu.pku.migrationhelper.service;

import edu.pku.migrationhelper.data.LibraryGroupArtifact;
import edu.pku.migrationhelper.mapper.LibraryGroupArtifactMapper;
import edu.pku.migrationhelper.mapper.LioProjectWithRepositoryMapper;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Service that provide evaluation facilities such as
 *   1. Loading and querying ground truth
 *   2. Select libraries by different criteria
 *   3. Evaluate a list of library candidates generated by DependencyChangePatternAnalysisService
 */
@Service
public class EvaluationService {

    public static class EvaluationResult {
        int rulesEvaluated;
        int maxK;
        public double[] topKPrecision;    // [i] means top-(i+1) precision
        public double[] topKRecall;       // [i] means top-(i+1) recall
        public double[] topKFMeasure;     // [i] means top-(i+1) f-measure
        Map<Long, double[]> precisionMap; // precision of individual libraries, indexed by GroupArtifactId
        Map<Long, double[]> recallMap;    // recall of individual libraries, indexed by GroupArtifactId
    }

    private final Logger LOG = LoggerFactory.getLogger(getClass());

    private static class GroundTruth {
        String fromLib;
        String toLib;
        List<String> fromGroupArtifacts;
        List<String> toGroupArtifacts;
        List<Long> fromGroupArtifactIds;
        List<Long> toGroupArtifactIds;
    }

    @Value("${migration-helper.evaluation.ground-truth-file}")
    private String groundTruthFile;

    @Autowired
    private LioProjectWithRepositoryMapper lioProjectWithRepositoryMapper;

    @Autowired
    private LibraryGroupArtifactMapper libraryGroupArtifactMapper;

    private List<GroundTruth> groundTruths;

    private Map<Long, Set<Long>> groundTruthMap;

    private Map<Long, LibraryGroupArtifact> groupArtifactCache;

    private long getGroupArtifactId(String name) {
        String[] ga = name.split(":");
        LibraryGroupArtifact lib = libraryGroupArtifactMapper.findByGroupIdAndArtifactId(ga[0], ga[1]);
        if (lib != null) {
            return lib.getId();
        } else {
            LOG.warn("{} does not exist in database", name);
            return -1;
        }
    }

    @PostConstruct
    public void initializeGroundTruth() throws IOException {
        groundTruths = new ArrayList<>();
        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(new FileReader(groundTruthFile))) {
            for (CSVRecord record : parser) {
                GroundTruth gt = new GroundTruth();
                gt.fromLib = record.get("fromLibrary");
                gt.toLib = record.get("toLibrary");
                if (!record.get("fromGroupArtifacts").equals(""))
                    gt.fromGroupArtifacts = Arrays.asList(record.get("fromGroupArtifacts").split(";"));
                else
                    gt.fromGroupArtifacts = new ArrayList<>();
                if (!record.get("toGroupArtifacts").equals(""))
                    gt.toGroupArtifacts = Arrays.asList(record.get("toGroupArtifacts").split(";"));
                else
                    gt.fromGroupArtifacts = new ArrayList<>();
                gt.fromGroupArtifactIds = gt.fromGroupArtifacts.stream()
                        .map(this::getGroupArtifactId).collect(Collectors.toList());
                gt.toGroupArtifactIds = gt.toGroupArtifacts.stream()
                        .map(this::getGroupArtifactId).collect(Collectors.toList());
                groundTruths.add(gt);
            }
        }
        groundTruthMap = new HashMap<>();
        for (GroundTruth gt : groundTruths) {
            for (Long fromId : gt.fromGroupArtifactIds) {
                groundTruthMap.computeIfAbsent(fromId, k -> new HashSet<>()).addAll(gt.toGroupArtifactIds);
            }
        }
    }

    @PostConstruct
    public synchronized void initializeGroupArtifactCache() {
        List<LibraryGroupArtifact> list = libraryGroupArtifactMapper.findAll();
        Map<Long, LibraryGroupArtifact> map = new HashMap<>(list.size() * 2);
        for (LibraryGroupArtifact groupArtifact : list) {
            map.put(groupArtifact.getId(), groupArtifact);
        }
        groupArtifactCache = Collections.unmodifiableMap(map);
    }

    /**
     * Evaluate library migration recommendation result based on the ground truth files constructed above
     * @param result result from DependencyChangeAnalysisService.miningLibraryMigrationCandidate()
     * @param maxK evaluate from top-1 to top-maxK
     * @return detailed evaluation result
     */
    public EvaluationResult evaluate(
            Map<Long, List<DependencyChangePatternAnalysisService.LibraryMigrationCandidate>> result,
            int maxK
    ) {
        EvaluationResult ret = new EvaluationResult();
        ret.precisionMap = new HashMap<>();
        ret.recallMap = new HashMap<>();
        ret.rulesEvaluated = 0;
        ret.maxK = maxK;

        result.entrySet().stream()
                .sorted(Comparator.comparingLong(Map.Entry::getKey))
                .forEach(entry -> {
                    long fromId = entry.getKey();
                    LibraryGroupArtifact fromLib = groupArtifactCache.get(fromId);
                    List<DependencyChangePatternAnalysisService.LibraryMigrationCandidate> candidateList = entry
                            .getValue().stream()
                            .filter(candidate -> { // Filter out candidates under same groupId, is this necessary?
                                LibraryGroupArtifact toLib = groupArtifactCache.get(candidate.toId);
                                return !Objects.equals(toLib.getGroupId(), fromLib.getGroupId());
                            }).collect(Collectors.toList());
                    if (candidateList.isEmpty()) return;
                    Set<Long> groundTruth = groundTruthMap.get(fromId);
                    if (groundTruth == null) return;
                    ret.rulesEvaluated += candidateList.size();
                    Set<Long> thisTruth = new HashSet<>();
                    for (DependencyChangePatternAnalysisService.LibraryMigrationCandidate candidate : candidateList) {
                        if (groundTruth.contains(candidate.toId)) {
                            thisTruth.add(candidate.toId);
                        }
                    }
                    if (thisTruth.isEmpty()) return;
                    //System.out.println(fromLib.getId() + ":" + fromLib.getGroupId() + ":" + fromLib.getArtifactId()
                    //        + ", Number of Candidates: " + candidateList.size());
                    //System.out.println("fromId: " + fromId + " groundTruth.size: " + groundTruth.size()
                    //        + " thisTruth.size: " + thisTruth.size());
                    int correct = 0;
                    double[] precision = new double[maxK];
                    double[] recall = new double[maxK];
                    for (int k = 1; k <= maxK; ++k) {
                        if (candidateList.size() < k) {
                            precision[k - 1] = precision[k - 2];
                            recall[k - 1] = recall[k - 2];
                        } else {
                            DependencyChangePatternAnalysisService.LibraryMigrationCandidate candidate = candidateList.get(k - 1);
                            if (groundTruth.contains(candidate.toId)) {
                                correct++;
                            }
                            precision[k - 1] = correct / (double) k;
                            // This recall calculation is outrageous and probably problematic...
                            // recall[k - 1] = correct / (double) thisTruth.size();
                            recall[k - 1] = correct / (double) groundTruth.size();
                        }
                    }
                    ret.precisionMap.put(fromId, precision);
                    ret.recallMap.put(fromId, recall);
                });

        ret.topKPrecision = new double[maxK];
        for (double[] value : ret.precisionMap.values()) {
            for (int i = 0; i < maxK; i++) {
                ret.topKPrecision[i] += value[i];
            }
        }
        ret.topKRecall = new double[maxK];
        for (double[] value : ret.recallMap.values()) {
            for (int i = 0; i < maxK; i++) {
                ret.topKRecall[i] += value[i];
            }
        }
        ret.topKFMeasure = new double[maxK];
        for (int k = 1; k <= maxK; k++) {
            double p = ret.topKPrecision[k - 1] / ret.precisionMap.size();
            double r = ret.topKRecall[k - 1] / ret.recallMap.size();
            double f = 2 * p * r / (p + r);
            ret.topKPrecision[k - 1] = p;
            ret.topKRecall[k - 1] = r;
            ret.topKFMeasure[k - 1] = f;
        }
        return ret;
    }

    public void printEvaluationResult(EvaluationResult result, PrintStream out) {
        out.println("Rules Evaluated: " + result.rulesEvaluated);
        for (int k = 1; k <= result.maxK; k++) {
            out.printf("Top %2d: Precision = %.4f, Recall = %.4f, F-Measure = %.4f\n",
                    k, result.topKPrecision[k - 1], result.topKRecall[k - 1], result.topKFMeasure[k - 1]);
        }
    }

    public List<Long> getLioProjectIdsInGroundTruth() {
        Set<Long> result = new HashSet<>();
        for (GroundTruth gt : groundTruths) {
            result.addAll(gt.fromGroupArtifacts.stream()
                    .map(s -> lioProjectWithRepositoryMapper.findByName(s).getId())
                    .collect(Collectors.toList()));
            result.addAll(gt.toGroupArtifacts.stream()
                    .map(s -> lioProjectWithRepositoryMapper.findByName(s).getId())
                    .collect(Collectors.toList()));
        }
        return new ArrayList<>(result);
    }

    public List<Long> getLioProjectIdsByCombinedPopularity(int limitCount) {
        LOG.info("Get libraries by combining results from different popularity measure, limit = {}", limitCount);

        Set<Long> idSet = new HashSet<>();
        List<Long> needParseIds = new LinkedList<>();
        Iterator<Long>[] idsArray = new Iterator[7];
        idsArray[0] = lioProjectWithRepositoryMapper.selectIdOrderByDependentProjectsCountLimit(limitCount).iterator();
        idsArray[1] = lioProjectWithRepositoryMapper.selectIdOrderByDependentRepositoriesCountLimit(limitCount).iterator();
        idsArray[2] = lioProjectWithRepositoryMapper.selectIdOrderByRepositoryForkCountLimit(limitCount).iterator();
        idsArray[3] = lioProjectWithRepositoryMapper.selectIdOrderByRepositoryStarCountLimit(limitCount).iterator();
        idsArray[4] = lioProjectWithRepositoryMapper.selectIdOrderByRepositoryWatchersCountLimit(limitCount).iterator();
        idsArray[5] = lioProjectWithRepositoryMapper.selectIdOrderBySourceRankLimit(limitCount).iterator();
        idsArray[6] = lioProjectWithRepositoryMapper.selectIdOrderByRepositorySourceRankLimit(limitCount).iterator();
        while (true) {
            boolean remain = false;
            for (Iterator<Long> longIterator : idsArray) {
                if (longIterator.hasNext()) {
                    remain = true;
                    long id = longIterator.next();
                    if (!idSet.contains(id)) {
                        needParseIds.add(id);
                        idSet.add(id);
                    }
                }
            }
            if(!remain) break;
        }
        return needParseIds;
    }
}

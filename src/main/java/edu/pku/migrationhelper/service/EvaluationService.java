package edu.pku.migrationhelper.service;

import edu.pku.migrationhelper.data.lib.LibraryGroupArtifact;
import edu.pku.migrationhelper.data.lio.LioProject;
import edu.pku.migrationhelper.repository.LioProjectRepository;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Service that provide evaluation facilities such as
 *   1. Loading and querying ground truth
 *   2. Select libraries by different criteria
 *   3. Evaluate a list of library candidates generated by DepSeqAnalysisService
 */
@Service
public class EvaluationService {

    public static class EvaluationResult {
        public int rulesEvaluated;
        public int maxK;
        public double[] topKPrecision;    // [i] means top-(i+1) precision
        public double[] topKRecall;       // [i] means top-(i+1) recall
        public double[] topKFMeasure;     // [i] means top-(i+1) f-measure
        public Map<Long, double[]> precisionMap; // precision of individual libraries, indexed by GroupArtifactId
        public Map<Long, double[]> recallMap;    // recall of individual libraries, indexed by GroupArtifactId
        public Map<Long, Map<Long, Boolean>> correctnessMap; // fromId -> toId -> whether it is in ground truth
    }

    private final Logger LOG = LoggerFactory.getLogger(getClass());

    private static class GroundTruth {
        String fromLib;
        String toLib;
        List<String> fromGroupArtifacts;
        List<String> toGroupArtifacts;
        List<Long> fromGroupArtifactIds;
        List<Long> toGroupArtifactIds;
    }

    @Value("${migration-helper.evaluation.ground-truth-file}")
    private String groundTruthFile;

    @Autowired
    private DepSeqAnalysisService depSeqAnalysisService;

    @Autowired
    private LioProjectRepository lioProjectRepository;

    @Autowired
    private GroupArtifactService groupArtifactService;

    private List<GroundTruth> groundTruths;

    private Map<Long, Set<Long>> groundTruthMap;

    @PostConstruct
    public void initializeGroundTruth() throws IOException {
        LOG.info("Initializing ground truth...");
        groundTruths = new ArrayList<>();
        try (CSVParser parser = CSVFormat.DEFAULT.withHeader().parse(new FileReader(groundTruthFile))) {
            for (CSVRecord record : parser) {
                GroundTruth gt = new GroundTruth();
                gt.fromLib = record.get("fromLibrary");
                gt.toLib = record.get("toLibrary");
                if (!record.get("fromGroupArtifacts").equals(""))
                    gt.fromGroupArtifacts = Arrays.asList(record.get("fromGroupArtifacts").split(";"));
                else
                    gt.fromGroupArtifacts = new ArrayList<>();
                if (!record.get("toGroupArtifacts").equals(""))
                    gt.toGroupArtifacts = Arrays.asList(record.get("toGroupArtifacts").split(";"));
                else
                    gt.fromGroupArtifacts = new ArrayList<>();
                gt.fromGroupArtifactIds = gt.fromGroupArtifacts.stream()
                        .map(groupArtifactService::getIdByName).collect(Collectors.toList());
                gt.toGroupArtifactIds = gt.toGroupArtifacts.stream()
                        .map(groupArtifactService::getIdByName).collect(Collectors.toList());
                groundTruths.add(gt);
            }
        }
        groundTruthMap = new HashMap<>();
        for (GroundTruth gt : groundTruths) {
            for (Long fromId : gt.fromGroupArtifactIds) {
                groundTruthMap.computeIfAbsent(fromId, k -> new HashSet<>()).addAll(gt.toGroupArtifactIds);
            }
            for (Long toId : gt.toGroupArtifactIds) {
                groundTruthMap.computeIfAbsent(toId, k -> new HashSet<>()).addAll(gt.fromGroupArtifactIds);
            }
        }
    }

    /**
     * Evaluate library migration recommendation result based on the ground truth files constructed above
     * @param result result from DepSeqAnalysisService.miningLibraryMigrationCandidate()
     * @param maxK evaluate from top-1 to top-maxK
     * @return detailed evaluation result
     */
    public EvaluationResult evaluate(
            Map<Long, List<DepSeqAnalysisService.LibraryMigrationCandidate>> result,
            int maxK
    ) {
        EvaluationResult ret = new EvaluationResult();
        ret.precisionMap = new HashMap<>();
        ret.recallMap = new HashMap<>();
        ret.correctnessMap = new HashMap<>();
        ret.rulesEvaluated = 0;
        ret.maxK = maxK;

        result.entrySet().stream()
                .sorted(Comparator.comparingLong(Map.Entry::getKey))
                .forEach(entry -> {
                    long fromId = entry.getKey();
                    LibraryGroupArtifact fromLib = groupArtifactService.getGroupArtifactById(fromId);
                    List<DepSeqAnalysisService.LibraryMigrationCandidate> candidateList = entry
                            .getValue().stream()
                            .filter(candidate -> { // Filter out candidates under same groupId, is this necessary?
                                LibraryGroupArtifact toLib = groupArtifactService.getGroupArtifactById(candidate.toId);
                                return !Objects.equals(toLib.getGroupId(), fromLib.getGroupId());
                            }).collect(Collectors.toList());

                    if (candidateList.isEmpty()) return;

                    for (DepSeqAnalysisService.LibraryMigrationCandidate candidate : candidateList) {
                        ret.correctnessMap.computeIfAbsent(candidate.fromId, k -> new HashMap<>());
                        ret.correctnessMap.get(candidate.fromId).put(candidate.toId, false);
                    }

                    Set<Long> groundTruth = groundTruthMap.get(fromId);
                    if (groundTruth == null) return;
                    ret.rulesEvaluated += candidateList.size();
                    Set<Long> thisTruth = new HashSet<>();
                    for (DepSeqAnalysisService.LibraryMigrationCandidate candidate : candidateList) {
                        if (groundTruth.contains(candidate.toId)) {
                            thisTruth.add(candidate.toId);
                            ret.correctnessMap.get(candidate.fromId).put(candidate.toId, true);
                        }
                    }
                    if (thisTruth.isEmpty()) return;
                    //System.out.println(fromLib.getId() + ":" + fromLib.getGroupId() + ":" + fromLib.getArtifactId()
                    //        + ", Number of Candidates: " + candidateList.size());
                    //System.out.println("fromId: " + fromId + " groundTruth.size: " + groundTruth.size()
                    //        + " thisTruth.size: " + thisTruth.size());
                    int correct = 0;
                    double[] precision = new double[maxK];
                    double[] recall = new double[maxK];
                    for (int k = 1; k <= maxK; ++k) {
                        if (candidateList.size() < k) {
                            precision[k - 1] = precision[k - 2];
                            recall[k - 1] = recall[k - 2];
                        } else {
                            DepSeqAnalysisService.LibraryMigrationCandidate candidate = candidateList.get(k - 1);
                            if (groundTruth.contains(candidate.toId)) {
                                correct++;
                            }
                            precision[k - 1] = correct / (double) k;
                            // This recall calculation is outrageous and probably problematic...
                            recall[k - 1] = correct / (double) thisTruth.size();
                            // This will make the recall result very low..
                            // recall[k - 1] = correct / (double) groundTruth.size();
                        }
                    }
                    ret.precisionMap.put(fromId, precision);
                    ret.recallMap.put(fromId, recall);
                });

        ret.topKPrecision = new double[maxK];
        for (double[] value : ret.precisionMap.values()) {
            for (int i = 0; i < maxK; i++) {
                ret.topKPrecision[i] += value[i];
            }
        }
        ret.topKRecall = new double[maxK];
        for (double[] value : ret.recallMap.values()) {
            for (int i = 0; i < maxK; i++) {
                ret.topKRecall[i] += value[i];
            }
        }
        ret.topKFMeasure = new double[maxK];
        for (int k = 1; k <= maxK; k++) {
            double p = ret.topKPrecision[k - 1] / ret.precisionMap.size();
            double r = ret.topKRecall[k - 1] / ret.recallMap.size();
            double f = 2 * p * r / (p + r);
            ret.topKPrecision[k - 1] = p;
            ret.topKRecall[k - 1] = r;
            ret.topKFMeasure[k - 1] = f;
        }
        return ret;
    }

    public void printEvaluationResult(EvaluationResult result, PrintStream out) {
        out.println("Rules Evaluated: " + result.rulesEvaluated);
        for (int k = 1; k <= result.maxK; k++) {
            out.printf("Top %2d: Precision = %.4f, Recall = %.4f, F-Measure = %.4f\n",
                    k, result.topKPrecision[k - 1], result.topKRecall[k - 1], result.topKFMeasure[k - 1]);
        }
    }

    public void runRQ1(
            Map<Long, List<DepSeqAnalysisService.LibraryMigrationCandidate>> result
    ) throws IOException {
        FileWriter output = new FileWriter("evaluation/pic/RQ1-pomOnly.csv");
        output.write("fromLib,toLib,isTruth,patternSupport,patternSupportP,occurCount,hot,hotRank\n");
        Set<String> missing = new HashSet<>();
        for (List<DepSeqAnalysisService.LibraryMigrationCandidate> candidateList : result.values()) {
            for (DepSeqAnalysisService.LibraryMigrationCandidate candidate : candidateList) {
                if (groundTruthMap.get(candidate.fromId) == null) {
                    missing.add(groupArtifactService.getGroupArtifactById(candidate.fromId).toString());
                    continue;
                }
                output.write(candidate.fromId + "," + candidate.toId + "," +
                        groundTruthMap.get(candidate.fromId).contains(candidate.toId) + "," +
                        candidate.ruleCount + "," +candidate.ruleSupportByMax + "," +
                        candidate.libraryConcurrenceCount + "," + candidate.libraryConcurrenceSupport + "," +
                        (candidate.ruleSupportByMax * candidate.libraryConcurrenceSupport) + "\n"
                );
            }
        }
        output.close();
        LOG.info("RunRQ1(), the following libraries are skipped because they are not in ground truth: {}", missing);
    }

    public void runRQ2() throws IOException {
        FileWriter truthPercent = new FileWriter("evaluation/pic/RQ2-truth-percent.csv");
        FileWriter truthPosition = new FileWriter("evaluation/pic/RQ2-truth-position.csv");
        truthPercent.write("fromId,truthCount,totalCount,percent\n");
        truthPosition.write("fromId,toId,isTruth,distance,total\n");
        for (List<Long> depSeq : depSeqAnalysisService.getRepositoryDepSeq()) {
            depSeq = depSeqAnalysisService.simplifyDepSeq(depSeq, null, null);
            List<DepSeqAnalysisService.LibraryMigrationPattern> patternList =
                    depSeqAnalysisService.miningSingleDepSeq(depSeq, groundTruthMap.keySet(), null);
            for (DepSeqAnalysisService.LibraryMigrationPattern pattern : patternList) {
                int pos = 1;
                Set<Long> truth = groundTruthMap.get(pattern.fromId);
                int truthCount = 0;
                int totalCount = pattern.toIdList.size();
                for (Long toId : pattern.toIdList) {
                    boolean isTruth = false;
                    if(truth.contains(toId)) {
                        isTruth = true;
                        truthCount++;
                    }
                    truthPosition.write(pattern.fromId+","+toId+","+isTruth+","+pos+","+totalCount+"\n");
                    ++pos;
                }
                double p = truthCount / (double) totalCount;
                truthPercent.write(pattern.fromId+","+truthCount+","+totalCount+","+p+"\n");
            }
        }
        truthPercent.close();
        truthPosition.close();
    }

    public void runRQ3(
            Map<Long, List<DepSeqAnalysisService.LibraryMigrationCandidate>> result
    ) throws IOException {
        FileWriter output = new FileWriter("evaluation/pic/RQ3.csv");
        output.write("fromId,toId,isTruth,APISupport,APIRank0,patternSupport\n");
        for (List<DepSeqAnalysisService.LibraryMigrationCandidate> candidateList : result.values()) {
            boolean containsTruth = false;
            for (DepSeqAnalysisService.LibraryMigrationCandidate candidate : candidateList) {
                Set<Long> s = groundTruthMap.get(candidate.fromId);
                if (s != null && s.contains(candidate.toId)) {
                    containsTruth = true;
                    break;
                }
            }
            if(!containsTruth) continue;
            for (DepSeqAnalysisService.LibraryMigrationCandidate candidate : candidateList) {
                boolean isTruth = groundTruthMap.get(candidate.fromId).contains(candidate.toId);
                output.write(candidate.fromId+","+candidate.toId+","+isTruth+","+candidate.methodChangeCount +","+candidate.methodChangeSupportByMax +","+candidate.ruleCount +"\n");
            }
        }
        output.close();
        LOG.info("Success");
    }

    public Map<Long, Set<Long>> getGroundTruthMap() {
        return groundTruthMap;
    }

    public List<Long> getLioProjectIdsInGroundTruth() {
        Set<Long> result = new HashSet<>();
        for (GroundTruth gt : groundTruths) {
            result.addAll(gt.fromGroupArtifacts.stream()
                    .map(s -> lioProjectRepository.findByName(s).get().getId())
                    .collect(Collectors.toList()));
            result.addAll(gt.toGroupArtifacts.stream()
                    .map(s -> lioProjectRepository.findByName(s).get().getId())
                    .collect(Collectors.toList()));
        }
        return new ArrayList<>(result);
    }

    public List<Long> getLioProjectIdsBy(String property, int limit, boolean ascending) {
        final List<String> legalProperties = Arrays.asList(
                "sourceRank", "repositoryStarCount", "repositoryForkCount",
                "repositoryWatchersCount", "repositorySourceRank", "dependentProjectsCount",
                "dependentRepositoriesCount");
        if (!legalProperties.contains(property)) {
            throw new IllegalArgumentException(
                    String.format("Unknown property %s, supported: %s", property, legalProperties));
        }
        PageRequest r;
        if (ascending) {
            r = PageRequest.of(0, limit, Sort.by(property).ascending());
        } else {
            r = PageRequest.of(0, limit, Sort.by(property).descending());
        }
        return lioProjectRepository.findAll(r).getContent()
                .stream().map(LioProject::getId).collect(Collectors.toList());
    }

    public List<Long> getLioProjectIdsByCombinedPopularity(int limitCount) {
        LOG.info("Get libraries by combining results from different popularity measure, limit = {}", limitCount);
        Set<Long> idSet = new HashSet<>();
        List<Long> needParseIds = new LinkedList<>();
        List<List<Long>> idsList = new ArrayList<>();
        idsList.add(getLioProjectIdsBy("sourceRank", limitCount, false));
        idsList.add(getLioProjectIdsBy("repositoryStarCount", limitCount, false));
        idsList.add(getLioProjectIdsBy("repositoryForkCount", limitCount, false));
        idsList.add(getLioProjectIdsBy("repositoryWatchersCount", limitCount, false));
        idsList.add(getLioProjectIdsBy("repositorySourceRank", limitCount, false));
        idsList.add(getLioProjectIdsBy("dependentProjectsCount", limitCount, false));
        idsList.add(getLioProjectIdsBy("dependentRepositoriesCount", limitCount, false));
        for (List<Long> ids : idsList) {
            for (long id : ids) {
                if (!idSet.contains(id)) {
                    needParseIds.add(id);
                    idSet.add(id);
                }
            }
        }
        return needParseIds;
    }
}
